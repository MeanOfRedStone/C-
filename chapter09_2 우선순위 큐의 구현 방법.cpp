/*
2. 우선순위 큐의 구현 방법
*배열을 사용하는 방법
(정렬 안된 배열을 사용할 경우)
-삽입 -> 배열의 맨 끝에 새로운 요소 추가
->시간 복잡도 O(1)
-삭제 : 우선 순위가 높은 요소 찾아야 함 -> 배열 모두 스캔해야 한다. -> 삭제 후 배열이동
->시간 복잡도 O(n)

(정렬이 되어 있는 배열)
-삽입 : 다른 요소와 비교해서 삽입 위치 결정 -> 배열 이동 후 삽입 결정
-삭제 : 맨 뒤에 위찬 요소(우선 순위 높음)

*연결 리스트를 사용하는 방법
-방식은 배열과 크게 다르지 않다.
(정렬 x)
삽입 &#8211; 시간복잡도 : O(1)
삭제 &#8211; 시간복잡도 O(n)

(정렬 ㅇ)
높은 우선순위일수록 리스트 앞 쪽에 배치.

*히프를 사용하는 방법.
-히프(head) :완전 이진 트리의 일종. -> 우선순위 큐를 위하여 특별히 만들어진 자료 구조.
-느슨한 정렬 상태 -> 효율 : O(log2n)

Quiz
1. 순서 없는 배열에 데이터를 삽입하였다가 가장 우선순위가 높은 데이터를 삭제하는 알고리즘 의사코드로 고안

배열 = A[100];
삽입 데이터 = data;
배열의 헤드 포인터 = top <- -1;

(삽입)
A[++top].data <- data;

(삭제)
delete_data = -9999
idx = -1
for n (0, top + 1) :
	if A[n].data > delete_data then delete_data = A[n].data, idx = n;
for n (idx, top + 1) :
	A[n].data = A[n+1].data;
top--;
2. 시간 복잡도
삽입 : O(1) / 삭제 : O(n)
*/
