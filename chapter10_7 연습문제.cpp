/*
1. 인접 행렬 adj_mat[][]에서 어떤 정점v의 진출 차수를 알고 싶으면 어떻게 하면 되는가?
정답: (1) 인접 행렬의 v번째 행의 값들을 전부 더한다.
-> 차수는 그 정점에 인접한 정점의 개수를 의미한다. 따라서 인접행렬의 v행은 v행에 연결된 정점을 의미하므로 모두 더해서 차수를 확인하면 된다.

2.인접 행렬이 {0, 1, 0, 0}, {1, 0, 1, 1}, {0, 1, 0, 0}, {0, 1, 0, 0} 이라면 여기에 대흥되는 인접 리스트를 그려라
<0> -> 1
<1> -> 0 -> 2 -> 3
<2> -> 1
<3> -> 1 

3. 정점의 개수를 n, 간선의 개수를 e라고 할 때, 인접 행렬에서 특정 정점의 차수를 계산하는 연산의 시간 복잡도는?
정답 : O(n)
->행렬에서 특정 정점의 차수만  조사해야하므로 n번의 조사가 필요하다. 

4. 정점의 개수를 n, 간선의 개수가 e인 그래프를 인접 리스트로 표현하였을 경우, 인접 리스트 상의 총 노드의 개수는?
정답 : (1)e개 
->인접 리스트에 간선의 개수만큼 노드를 표현해줘야하기 때문이다.

5.다음 중 큐를 사용하는 알고리즘은?
(2) 너비 우선탐색

6. 다음 그래프를 인접 행렬과 인접 리스트로 표현해보자.
정답:
(1) 인접행렬 : {0, 1, 0, 0, 1}, {1, 0, 1, 1, 0}, {0, 1, 0, 0, 1}, {0, 1, 0, 0, 1}, {1, 0, 1, 1 ,0} 
(2) 인접 리스트: 
<0> -> 1 -> 4
<1> -> 0 -> 2 -> 3
<2> -> 1 -> 4
<3> -> 1 -> 4
<4> -> 0 -> 2 -> 3

7. 다음의 방향 그래프에 대하여 다음 질문에 답하여라 
(1) 각 정점의 진입차수와 진출차수
<0> 진입 차수: 3 / 진출 차수 : 1, 2, 3
<1> 진입 차수: 0, 4 / 진출 차수 : 2, 3
<2> 진입 차수: 0, 1, 4 / 진출 차수 : 4
<3> 진입 차수: 0, 1 / 진출 차수 : 0, 4
<4> 진입 차수: 2, 3, 5 / 진출 차수 : 1, 2
<5> 진입 차수: null / 진출 차수 : 4

(2)각 정점에 인접한 정점들의 집합  
<0> : 1, 2, 3
<1> : 0 ,2 ,3, 4
<2> : 0, 1, 4
<3> : 0, 1, 4
<4> : 1, 2, 3, 5
<5> : 4

(3) 인접 행렬 표현
{0, 1, 1, 1, 0, 0}, {0, 0, 1, 1, 0, 0}, {1, 0, 0, 0, 1, 0}, {1, 0, 0, 0, 1, 0}, {0, 1, 1, 0, 0, 0}, {0, 0, 0, 0, 1, 0}

(4)인접 리스트 표현 
생략

(5) 모든 사이클과 그 길이 
생략

8.	정점 V = {1, 2, 3, 4, 5}
	간선 E = {<1, 2>, <1, 3>, <1, 4>, <2, 1>, <2, 3>, <2, 5>, <3, 1>, <3, 2>, <3, 4>, <3, 5>, <4, 2>, <5, 1>, <5, 3>}
	-> 책에 표현 

9. 크기가 n x n인 방향 그래프 a가 n x n 인접 배열을 사용하여 표현되어 있다. 
(1) 주어진 정점의 진출차수(out-degree)을 계산하는 함수를 작성하라.
	진출차수란 어떤 정점에서 출발하여 외부가 나가는 간선의 개수이다.이 함수의 시간 복잡도는? 


int calc_out_degree(GraphType * g, int v)
{
	count = 0;
	for(int i = 0; i < g->n; i++){
		if(g->adj[v][i] == 1){
			count += 1;
		}
	}
	return count;
}

시간 복잡도 : O(n)
1개의 정점에 연결된 노드만 조사하면 되므로 n개만 조사하면 된다. 

(2) 주어진 정점의 진입차수(in-degree)을 계산하는 함수를 작성하라.
	진입차수란 어떤 정점으로 들어오는 간선의 개수이다. 이 함수의 시간 복잡도는?

int calc_in_degree(GraphType * g, int v)
{
	count = 0;
	for(int i = 0; i < g->n; i++){
		if(g->adj[i][v] == 1){
			count += 1;
		}
	}
	return count;
} 

시간 복잡도 : O(n)
n개의 정점에서 1개씩만 조사하면 되므로 O(n)이다.

(3) 그래프 안에 있는 간선들의 개수를 계산하는 함수를 작성하라. 이 함수의 시간 복잡도는?

int calc_degree(GraphType * g)
{
	count = 0;
	for(int i = 0; i < g->n; i++){
		for(int j = 0; i < g->n; j++){
			if(g->adj[i][j] == 1){
				count += 1;
			} 
		}
	}
	return count;
} 

시간 복잡도 : O(n^2)

10. 만약 그래프가 인접 리스트로 표현되어 있다고 가정하고 앞의 문제를 다시 작성하라.
(1) 주어진 정점의 진출차수(out-degree)을 계산하는 함수를 작성하라.
	진출차수란 어떤 정점에서 출발하여 외부가 나가는 간선의 개수이다.이 함수의 시간 복잡도는? 

int calc_out_degree(GraphType * g, int v)
{
	count = 0;
	GraphNode * node;
	for(node = g->adj_list[v]; node != NULL; node = node->link)	{
		count += 1;
	}
} 

시간 복잡도 : O(n) 

(2) 주어진 정점의 진입차수(in-degree)을 계산하는 함수를 작성하라.
	진입차수란 어떤 정점으로 들어오는 간선의 개수이다. 이 함수의 시간 복잡도는?

int calc_in_degree(GraphType * g, int v)
{
	count = 0;
	GraphNode * node;
	for(int i = 0; i < g->n; i++){
		node = g->adj_list[i];
		for(node; node != NULL; node = node->link)	{
			if(node->vertex == v){
				count += 1;	
			}
			
		}
	}
	return count;
}

시간 복잡도 : O(n + e)
n개의 노드를 간선 수만큼 돌아야한다.

(3) 그래프 안에 있는 간선들의 개수를 계산하는 함수를 작성하라. 이 함수의 시간 복잡도는?
int calc_degree(GraphType * g)
{
	count = 0;
	GraphNode * node;
	for(int i = 0; i < g->n; i++){
		node = g->adj_list[i];
		for(node; node != NULL; node = node->link)	{
			count += 1;
		}
	}
	return count;
} 

시간 복잡도 : O(n + e)
n개의 노드를 간선 수만큼 돌아야한다.

11. 3, 4, 5개의 정점으로 된 무방향 완전 그래프를 그렵라. n개의 정점을 갖는 완전 그래프의 간선의 개수가 n(n-1)/2인지를 확인하라.
자기를 제외한 정점과 연결해야하므로 한정점당 n-1개 씩 연결 총 n(n-1)개 무방향 그래프는 진출차수 진입차수구분이 없으므로 2로 나눈다.
*/ 

/*
12. 하드 디스크에 파일로 그래프의 인접 행렬이 저장되어 있다고 가정하고 다음과 같은 함수를 작성하라.
	그래프 파일의 형식은 다음과 같다.
	
4		-정점의 개수

0 1 1 1	-인접 행렬 
1 0 1 1
1 1 0 1
1 1 1 0 

read_graph_mat (GraphType * g, char * name) : 이름이 name인 그래프 파일을 읽어서 그래프 g의 인접 행렬에 저장
write_graph_mat(GraphType * g, char * name) : 그래프 g의 인접 행렬을 이름이 name인 그래프 파일에 저장

typedef struct GraphType{
	int n;
	int adj_mat[MAX_VERTICES][MAX_VERTICES]
} GraphType;

void read_graph_mat(GraphType * g, char * name)
{
	for(int i = 0; i < g->n; i++){
		for(int j = 0; j < g->n; j++){
			adj_mat[i][j] = name[i][j]
		}
	}
}

*/

/*
13. 다음의 그래프에 대하여 답하라. 그래프는 인접행렬로 표현되어 있다고 가정하라.
깊이 우선 탐색: 트리와 유사 
(1) 정점 3에서 출발하여 깊이 우선 탐색햇을 경우 방문 순서
3 - 1 - 0 - 2 - 4 - 5 - 6 - 7- 8 - 9 
(2) 정점 6에서 출발하여 깊이 우선탐색했을 경우의 방문순서
6 - 5 - 3 - 1 - 0 - 2 - 4 - 7 - 8 - 9

너비 우선 탐색: 가까운 정점부터 방문 (큐를 활용) 
(3) 정점3에서 출발하여 너비 우선탐색했을 경우의 방문순서
3 - 1 - 4 - 5 - 0 - 2 - 6 - 7 - 8 - 9

(4) 정점6에서 출발하여 너비 우선탐색했을 경우의 방문순서
6 - 5 - 7 - 3 - 8 - 9 - 1 - 4 - 0 - 2
 
*/ 

/*
14. 연결된 그래프 G의 간선들 중에서 그 간선을 제거하면 연결이 끊어지는 간선 (u, v)를 브리지라고 한다.
	주어진 그래프에서 브릿지를 찾아내는 함수를 저장하라. 
*/
0 - 1 | 3 - 5 | 7 - 8 | 7 - 9

0 1 0 0 0 0 0 0 0 0
1 0 1 1 0 0 0 0 0 0
0 1 0 0 1 0 0 0 0 0
0 1 0 0 1 1 0 0 0 0
0 0 1 1 0 0 0 0 0 0
0 0 0 1 0 0 1 1 0 0
0 0 0 0 0 1 0 1 0 0
0 0 0 0 0 1 1 0 1 1

0 1 2 4 3

/*
15. 다음의 인접 리스트는 어떤 그래프를 표현한 것이다. 이 그래프를 정점 A에서부터 깊이 우선
탐색할 때, 정점이 방문되는 순서로 옳은 것은? 
A - B - E - F - C - D - G
*/
